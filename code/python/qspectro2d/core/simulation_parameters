# =============================
# DEFINE THE SIMULATION PARAMETERS CLASS
# =============================
from dataclasses import dataclass, field  # for the class definiton
from typing import Optional  # for the class definiton
from matplotlib.pylab import f
import numpy as np
from qspectro2d.core.pulse_sequences import PulseSequence
from qspectro2d.core.system_parameters import SystemParameters
from qspectro2d.core.utils_and_config import convert_cm_to_fs, convert_fs_to_cm, HBAR, BOLTZMANN

@dataclass
class SimulationConfig:
    # =============================
    # Solver and model control
    # =============================
    ODE_Solver: str = (
        "Paper_BR"  # "Paper_eqs" (solve the EOMs from the paper) or "Paper_BR" do d/dt rho = -i/hbar * [H0 - Dip * E, rho] + R(rho)
    )
    RWA_laser: bool = (
        True  #  CAN ONLY HANDLE TRUE For Paper_eqs   #   only valid for omega_laser ~ omega_A
    )

@dataclass
class SimulationModel:
    system: SystemParameters
    pulse: PulseSequence
    simulation: SimulationConfig # TODO define SimulationConfig class

    # TODO somehow make include this
    self.H0 = (self.H0_diagonalized)  # Access property, self.H0 should become a Qobj

    """ 
    # DERIVED QUANTITIES FROM SYSTEM / LASER PARAMETERS
    @property
    def rabi_0(self):
        return self.mu_A * self.E0 / self.hbar

    @property
    def delta_rabi(self):
        return self.omega_laser - self.omega_A

    @property
    def rabi_gen(self):
        return np.sqrt(self.rabi_0**2 + self.delta_rabi**2)

    @property
    def t_prd(self):
        return 2 * np.pi / self.rabi_gen if self.rabi_gen != 0 else 0.0
    """




    # OBSERVABLES (what the simulation should keep track of)
    @property
    def observable_ops(self):
        if self.N_atoms == 1:
            observable_ops = [
                ket2dm(self.atom_g),  # |gxg|
                self.atom_g * self.atom_e.dag(),  # |gxe|
                self.atom_e * self.atom_g.dag(),  # |exg|
                ket2dm(self.atom_e),  # |exe|
            ]
        elif self.N_atoms == 2:
            """
            observable_ops1 = [
                ket2dm(tensor(self.atom_g, self.atom_g)),
                ket2dm(tensor(self.atom_e, self.atom_g)),
                ket2dm(tensor(self.atom_g, self.atom_e)),
                ket2dm(tensor(self.atom_e, self.atom_e)),
            ]
            """
            observable_ops2 = [ket2dm(state) for state in self.eigenstates[1]]

            observable_ops = observable_ops2

        else:
            raise ValueError("Only N_atoms=1 or 2 are supported.")

        return observable_ops

    @property
    def observable_strs(self):
        if self.N_atoms == 1:
            observable_strs = ["gg", "ge", "eg", "ee"]
        elif self.N_atoms == 2:
            # observable_strs1 = ["0", "A", "B", "AB"]
            observable_strs2 = [f"{i}" for i in range(len(self.eigenstates[1]))]
            observable_strs = observable_strs2

        else:
            raise ValueError("Only N_atoms=1 or 2 are supported.")

        return observable_strs


    def summary(self):
        print("\n# Summary of System Parameters:")
        for key, value in self.__dict__.items():
            print(f"    {key:<20}: {value}")

        # Solver Specifics
        print("\n# Solver specific information:")
        if self.ODE_Solver == "ME":
            print(f"    {'me_decay_channels':<20}:")
            for op in self.me_decay_channels:
                print(f"        {op}")
        elif self.ODE_Solver == "BR":
            print(f"    {'br_decay_channels':<20}:")
            for op_spec in self.br_decay_channels:
                if isinstance(op_spec, list) and len(op_spec) == 2:
                    print(f"        Operator: {op_spec[0]}, Spectrum: {op_spec[1]}")
                else:
                    print(f"        {op_spec}")
        elif self.ODE_Solver == "Paper_BR":
            print(f"    {'Redfield tensor R_paper used (calculated by R_paper(self))'}")
            # Optionally print the R_paper matrix if it's not too large
            # print(R_paper(self))
        elif self.ODE_Solver == "Paper_eqs":
            print(
                f"    {'Custom ODE matrix used (calculated by matrix_ODE_paper(t, pulse_seq, self))'}"
            )

    def gamma_small_ij(self, i: int, j: int) -> float:
        """
        Calculate the population relaxation rates.

        Parameters:
            i (int): Index of the first state.
            j (int): Index of the second state.

        Returns:
            float: Population relaxation rate.
        """

        w_ij = self.omega_ij(i, j)
        return np.sin(2 * self.theta) ** 2 * power_spectrum_func_paper(
            w_ij, self.args_bath()
        )

    def Gamma_big_ij(self, i: int, j: int) -> float:
        """
        Calculate the pure dephasing rates.

        Parameters:
            i (int): Index of the first state.
            j (int): Index of the second state.

        Returns:
            float: Pure dephasing rate.
        """
        # Pure dephasing rates helper
        P_0 = power_spectrum_func_paper(0, self.args_bath())
        Gamma_t_ab = 2 * np.cos(2 * self.theta) ** 2 * P_0  # tilde
        Gamma_t_a0 = (1 - 0.5 * np.sin(2 * self.theta) ** 2) * P_0
        Gamma_11 = self.gamma_small_ij(2, 1)
        Gamma_22 = self.gamma_small_ij(1, 2)
        Gamma_abar_0 = 2 * P_0
        Gamma_abar_a = Gamma_abar_0  # holds for dimer
        if i == 1:
            if j == 0:
                return Gamma_t_a0 + 0.5 * self.gamma_small_ij(2, i)
            elif j == 1:
                return Gamma_11
            elif j == 2:
                return Gamma_t_ab + 0.5 * (
                    self.gamma_small_ij(i, j) + self.gamma_small_ij(j, i)
                )
        if i == 2:
            if j == 0:
                return Gamma_t_a0 + 0.5 * self.gamma_small_ij(1, i)
            elif j == 1:
                return Gamma_t_ab + 0.5 * (
                    self.gamma_small_ij(i, j) + self.gamma_small_ij(j, i)
                )
            elif j == 2:
                return Gamma_22
        elif i == 3:
            if j == 0:
                return Gamma_abar_0
            elif j == 1:
                return Gamma_abar_a + 0.5 * (self.gamma_small_ij(2, j))
            elif j == 2:
                return Gamma_abar_a + 0.5 * (self.gamma_small_ij(1, j))
        else:
            raise ValueError("Invalid indices for i and j.")

